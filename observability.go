package kapi

import (
	"context"
	"log/slog"
	"slices"
	"strconv"
	"time"

	"math/rand"
)

type (
	// ObservabilityConfig defines the mechanisms by which logs, metrics and traces are processed
	ObservabilityConfig struct {
		// Context specifies the context to be used for logs generated by background operations or internal ctrl-runtime activity
		BackgroundContext context.Context
		// LogFunc should be set to a context aware, levelled and structured logger implementation.
		// - level defines the verbosity, where a higher value indicates and increased level of detail.
		// - message defines a summary of the log event
		// - attributes is a variadic list of variables that are parsed as kv pairs and used as structured log attributes
		LogFunc func(ctx context.Context, level int, msg string, attributes ...any)
		// MetricTimerFunc should be set to a suitable, context aware metric or trace func able to write count and duration metrics with dimensions/attributes
		MetricTimerFunc func(ctx context.Context, metric string) func(attributes ...string)
		// NewCorrelationCtx is defines a func that generates a new correlation context for the purposes of logs or tracing.
		// This is called at the start of each reconciliation allowing activities associated with it to be correlated
		NewCorrelationCtx func(ctx context.Context) context.Context
	}
)

// UseSlog generates a kapi.ObservabilityConfig based on a passed slog.Logger
func UseSlog(ctx context.Context, log *slog.Logger) ObservabilityConfig {

	type correlationIDKey struct{}

	newCorrelationCtx := func(ctx context.Context) context.Context {
		return context.WithValue(ctx, correlationIDKey{}, strconv.FormatInt(rand.Int63(), 10))
	}

	mainCorrelationID := strconv.FormatInt(rand.Int63(), 10)

	return ObservabilityConfig{
		BackgroundContext: newCorrelationCtx(ctx),
		LogFunc: func(ctx context.Context, level int, msg string, attributes ...any) {
			correlationID, _ := ctx.Value(correlationIDKey{}).(string)

			if correlationID == "" {
				correlationID = mainCorrelationID
			}

			slogLevel := slog.LevelDebug
			switch level {
			case 0:
				slogLevel = slog.LevelError
			case 1:
				slogLevel = slog.LevelWarn
			case 2:
				slogLevel = slog.LevelInfo
			}
			log.Log(ctx, slogLevel, msg, append(attributes, "correlation_id", correlationID)...)
		},
		MetricTimerFunc: func(ctx context.Context, metric string) func(attributes ...string) {
			t := time.Now()
			return func(attributes ...string) {
				attr := make([]any, 0, len(attributes)+4)

				for _, a := range slices.All(attributes) {
					attr = append(attr, a)
				}

				log.Log(ctx, slog.LevelInfo, metric, append(attr, "type", "metric", "duration", time.Since(t).Milliseconds())...)
			}
		},
		NewCorrelationCtx: newCorrelationCtx,
	}
}
